# è¯æ³•åˆ†æç”Ÿæˆå™¨å®ç°è¯´æ˜

## ğŸ“‹ æ¦‚è¿°

æœ¬æ¨¡å—å®ç°äº† Member Aï¼ˆè¯æ³•åˆ†æç”Ÿæˆä¸“å®¶ï¼‰çš„æ‰€æœ‰åŠŸèƒ½ï¼Œè´Ÿè´£å°†æ­£åˆ™è¡¨è¾¾å¼è‡ªåŠ¨è½¬æ¢ä¸º DFAï¼ˆç¡®å®šæœ‰é™è‡ªåŠ¨æœºï¼‰ï¼Œç”¨äºç”Ÿæˆè¯æ³•åˆ†æå™¨ã€‚

## ğŸ¯ æ ¸å¿ƒä»»åŠ¡

æ ¹æ®é¡¹ç›®è¦æ±‚ï¼Œå®ç°äº†ä»¥ä¸‹ä¸‰ä¸ªæ ¸å¿ƒç®—æ³•ï¼š

1. âœ… **Thompson ç®—æ³•** - æ­£åˆ™è¡¨è¾¾å¼ â†’ NFAï¼ˆéç¡®å®šæœ‰é™è‡ªåŠ¨æœºï¼‰
2. âœ… **å­é›†æ„é€ æ³•** - NFA â†’ DFAï¼ˆç¡®å®šæœ‰é™è‡ªåŠ¨æœºï¼‰
3. âœ… **Hopcroft ç®—æ³•** - DFA æœ€å°åŒ–ï¼ˆå¯é€‰ä½†å·²å®ç°ï¼‰

## ğŸ“ æ–‡ä»¶ç»“æ„

### ä¿®æ”¹çš„æ–‡ä»¶

- `LexerGenerator.h` - æ·»åŠ äº† NFA å’Œ DFA æ•°æ®ç»“æ„å®šä¹‰ï¼Œä»¥åŠæ‰€æœ‰ç®—æ³•å‡½æ•°å£°æ˜
- `LexerGenerator.cpp` - å®ç°äº†æ‰€æœ‰æ ¸å¿ƒç®—æ³•ï¼ˆçº¦ 700 è¡Œä»£ç ï¼‰

### æ–°å¢çš„æ•°æ®ç»“æ„

```cpp
// NFA çŠ¶æ€
struct NFAState {
    int id;                                    // çŠ¶æ€ID
    bool isFinal;                              // æ˜¯å¦ä¸ºç»ˆæ€
    std::string tokenName;                     // Tokenåç§°
    std::map<char, std::set<int>> transitions; // å­—ç¬¦è½¬æ¢
    std::set<int> epsilonTransitions;          // epsilonè½¬æ¢
};

// NFA ç»“æ„
struct NFA {
    int startState;                    // èµ·å§‹çŠ¶æ€
    int endState;                      // ç»ˆæ€
    std::map<int, NFAState> states;   // çŠ¶æ€é›†åˆ
};

// DFA å­é›†çŠ¶æ€
struct DFASubset {
    std::set<int> nfaStates;           // åŒ…å«çš„NFAçŠ¶æ€
    bool isFinal;                      // æ˜¯å¦ä¸ºç»ˆæ€
    std::string tokenName;             // Tokenåç§°
    int dfaStateID;                    // DFAçŠ¶æ€ID
    std::map<char, int> transitions;   // å­—ç¬¦è½¬æ¢
};
```

## ğŸ”§ å®ç°çš„å‡½æ•°

### 1. æ­£åˆ™è¡¨è¾¾å¼å¤„ç†

- `preprocessRegex()` - é¢„å¤„ç†æ­£åˆ™è¡¨è¾¾å¼
  - å¤„ç†è½¬ä¹‰å­—ç¬¦ï¼ˆ`\n`, `\t`, `\r`ï¼‰
  - å±•å¼€å­—ç¬¦ç±»ï¼ˆ`[0-9]` â†’ `(0|1|2|...|9)`ï¼‰
  
- `regexToPostfix()` - è½¬æ¢ä¸ºåç¼€è¡¨è¾¾å¼
  - æ”¯æŒæ“ä½œç¬¦ï¼š`*`, `+`, `?`, `|`, `.`ï¼ˆè¿æ¥ï¼‰
  - å¤„ç†è¿ç®—ç¬¦ä¼˜å…ˆçº§

### 2. Thompson ç®—æ³•

- `regexToNFA()` - æ­£åˆ™è¡¨è¾¾å¼ â†’ NFA
  - å¤„ç†å•ä¸ªå­—ç¬¦
  - å¤„ç†è¿æ¥æ“ä½œï¼ˆ`.`ï¼‰
  - å¤„ç†é€‰æ‹©æ“ä½œï¼ˆ`|`ï¼‰
  - å¤„ç† Kleene é—­åŒ…ï¼ˆ`*`ï¼‰
  - å¤„ç†æ­£é—­åŒ…ï¼ˆ`+`ï¼‰
  - å¤„ç†å¯é€‰æ“ä½œï¼ˆ`?`ï¼‰

### 3. NFA åˆå¹¶

- `mergeNFAs()` - åˆå¹¶å¤šä¸ª NFA
  - å°†å¤šæ¡è§„åˆ™çš„ NFA åˆå¹¶ä¸ºä¸€ä¸ªç»Ÿä¸€çš„ NFA
  - åˆ›å»ºæ–°çš„èµ·å§‹çŠ¶æ€ï¼Œç”¨ epsilon è¾¹è¿æ¥åˆ°å„ä¸ª NFA

### 4. å­é›†æ„é€ æ³•

- `epsilonClosure()` - è®¡ç®— epsilon é—­åŒ…
  - é€šè¿‡ epsilon è¾¹å¯è¾¾çš„æ‰€æœ‰çŠ¶æ€
  
- `move()` - è®¡ç®—çŠ¶æ€è½¬æ¢
  - çŠ¶æ€é›†åˆåœ¨æŸä¸ªå­—ç¬¦ä¸‹çš„è½¬æ¢ç›®æ ‡

- `nfaToDFA()` - NFA â†’ DFA
  - ä½¿ç”¨å­é›†æ„é€ ç®—æ³•
  - æ„å»ºå®Œæ•´çš„ DFA è½¬æ¢è¡¨

### 5. DFA æœ€å°åŒ–

- `minimizeDFA()` - Hopcroft ç®—æ³•
  - åŸºäºç­‰ä»·ç±»åˆ’åˆ†
  - å‡å°‘ DFA çŠ¶æ€æ•°é‡
  - æé«˜è¯æ³•åˆ†ææ•ˆç‡

### 6. æ ¼å¼è½¬æ¢

- `convertToDFATable()` - è½¬æ¢ä¸ºè¾“å‡ºæ ¼å¼
  - å°†å†…éƒ¨ DFA è¡¨ç¤ºè½¬æ¢ä¸º `DFATable` æ ¼å¼
  - ä¾›ä»£ç ç”Ÿæˆå™¨ä½¿ç”¨

### 7. ä¸»å‡½æ•°

- `build()` - ä¸»æ„å»ºæµç¨‹
  - æ•´åˆæ‰€æœ‰ç®—æ³•
  - è¾“å‡ºè°ƒè¯•ä¿¡æ¯

## ğŸ”„ ç®—æ³•æµç¨‹

```
è¾“å…¥ï¼šè¯æ³•è§„åˆ™åˆ—è¡¨
  â†“
1. é¢„å¤„ç†æ­£åˆ™è¡¨è¾¾å¼ï¼ˆè½¬ä¹‰ã€å­—ç¬¦ç±»å±•å¼€ï¼‰
  â†“
2. è½¬æ¢ä¸ºåç¼€è¡¨è¾¾å¼
  â†“
3. Thompsonç®—æ³•ï¼šä¸ºæ¯æ¡è§„åˆ™æ„å»ºNFA
  â†“
4. åˆå¹¶æ‰€æœ‰NFAä¸ºä¸€ä¸ªç»Ÿä¸€NFA
  â†“
5. å­é›†æ„é€ æ³•ï¼šNFA â†’ DFA
  â†“
6. Hopcroftç®—æ³•ï¼šæœ€å°åŒ–DFA
  â†“
7. è½¬æ¢ä¸ºDFATableæ ¼å¼
  â†“
è¾“å‡ºï¼šDFAè½¬æ¢è¡¨
```

## ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹

```cpp
// åˆ›å»ºç”Ÿæˆå™¨
LexerGenerator lexGen;

// æ·»åŠ è¯æ³•è§„åˆ™
lexGen.addRule("NUM", "[0-9]+");           // æ•°å­—
lexGen.addRule("ID", "[a-zA-Z_]+");         // æ ‡è¯†ç¬¦
lexGen.addRule("PLUS", "\\+");              // åŠ å·
lexGen.addRule("WHILE", "while");           // å…³é”®å­—

// æ„å»ºDFA
lexGen.build();

// è·å–ç”Ÿæˆçš„DFAè¡¨
const DFATable& dfaTable = lexGen.getDFATable();
```

## ğŸ“Š æ”¯æŒçš„æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ€§

| ç‰¹æ€§ | ç¤ºä¾‹ | è¯´æ˜ |
|------|------|------|
| å­—ç¬¦ç±» | `[0-9]` | åŒ¹é…æ•°å­— |
| èŒƒå›´ | `[a-z]` | åŒ¹é…å°å†™å­—æ¯ |
| Kleeneé—­åŒ… | `a*` | 0æ¬¡æˆ–å¤šæ¬¡ |
| æ­£é—­åŒ… | `a+` | 1æ¬¡æˆ–å¤šæ¬¡ |
| å¯é€‰ | `a?` | 0æ¬¡æˆ–1æ¬¡ |
| é€‰æ‹© | `a\|b` | a æˆ– b |
| è½¬ä¹‰ | `\\+` | åŒ¹é…åŠ å·å­—ç¬¦ |
| è½¬ä¹‰å­—ç¬¦ | `\n`, `\t` | æ¢è¡Œã€åˆ¶è¡¨ç¬¦ |

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **è§„åˆ™ä¼˜å…ˆçº§**ï¼šè§„åˆ™æŒ‰æ·»åŠ é¡ºåºç¡®å®šä¼˜å…ˆçº§
2. **å­—ç¬¦ç±»**ï¼šå½“å‰æ”¯æŒç®€å•èŒƒå›´ï¼ˆå¦‚ `[0-9]`ï¼‰ï¼Œå¤æ‚å­—ç¬¦ç±»å¯èƒ½éœ€è¦æ‰©å±•
3. **è½¬ä¹‰**ï¼šç‰¹æ®Šå­—ç¬¦éœ€è¦è½¬ä¹‰ï¼ˆå¦‚ `\+`, `\-`, `\*`ï¼‰
4. **æ€§èƒ½**ï¼šå¤§å‹æ­£åˆ™è¡¨è¾¾å¼å¯èƒ½äº§ç”Ÿå¤§é‡çŠ¶æ€

## ğŸ“ˆ è¾“å‡ºç¤ºä¾‹

è¿è¡Œæ—¶ä¼šè¾“å‡ºè¯¦ç»†çš„æ„å»ºä¿¡æ¯ï¼š

```
[LexerGen] Added rule: NUM -> [0-9]+
[LexerGen] Added rule: ID -> [a-zA-Z_]+
[LexerGen] Building DFA from 2 rules...
[LexerGen] Converting regex to NFA: NUM -> [0-9]+
[LexerGen] Converting regex to NFA: ID -> [a-zA-Z_]+
[LexerGen] Merging NFAs...
[LexerGen] Converting NFA to DFA (Subset Construction)...
[LexerGen] DFA has 15 states.
[LexerGen] Minimizing DFA (Hopcroft Algorithm)...
[LexerGen] Minimized DFA has 8 states.
[LexerGen] Build complete!
```

## âœ… å®Œæˆæƒ…å†µ

- [x] Thompson ç®—æ³•å®ç°
- [x] å­é›†æ„é€ æ³•å®ç°
- [x] Hopcroft DFA æœ€å°åŒ–ç®—æ³•å®ç°
- [x] æ­£åˆ™è¡¨è¾¾å¼é¢„å¤„ç†
- [x] å­—ç¬¦ç±»æ”¯æŒ
- [x] è½¬ä¹‰å­—ç¬¦å¤„ç†
- [x] å¤šæ¡è§„åˆ™åˆå¹¶
- [x] DFA è¡¨ç”Ÿæˆ
- [x] è°ƒè¯•ä¿¡æ¯è¾“å‡º

## ğŸ”— ç›¸å…³æ–‡ä»¶

- `LexerGenerator.h` - å¤´æ–‡ä»¶ï¼ŒåŒ…å«æ‰€æœ‰å£°æ˜
- `LexerGenerator.cpp` - å®ç°æ–‡ä»¶ï¼ŒåŒ…å«æ‰€æœ‰ç®—æ³•
- `Types.h` - åŒ…å« `DFATable` ç­‰ç±»å‹å®šä¹‰
- `main.cpp` - ä¸»ç¨‹åºï¼Œè°ƒç”¨ LexerGenerator
- `CodeEmitter.cpp` - ä½¿ç”¨ç”Ÿæˆçš„ DFA è¡¨ç”Ÿæˆä»£ç 

## ğŸ“š ç®—æ³•å‚è€ƒ

1. **Thompson ç®—æ³•**ï¼šç»å…¸çš„æ­£åˆ™è¡¨è¾¾å¼åˆ° NFA è½¬æ¢ç®—æ³•
2. **å­é›†æ„é€ æ³•**ï¼šNFA åˆ° DFA çš„æ ‡å‡†è½¬æ¢æ–¹æ³•
3. **Hopcroft ç®—æ³•**ï¼šé«˜æ•ˆçš„ DFA æœ€å°åŒ–ç®—æ³•

---

**å®ç°è€…**ï¼šMember A - è¯æ³•åˆ†æç”Ÿæˆä¸“å®¶  
**å®Œæˆæ—¥æœŸ**ï¼š2024-01-01

